<!DOCTYPE HTML>
<html lang="en">
	<head>
		<title>three.js webgl - dynamic procedural terrain</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style type="text/css">
			body {
				background: #000;
				color: #999;
				padding: 0;
				margin: 0;
				overflow: hidden;
				font-family: georgia;
				font-size:1em;
				text-align: center;
			}

			#info { position: absolute; top: 10px; width: 100%; }

			a { color: #fb0; }

			#footer { position: absolute; bottom: 10px; width: 100%; }
			.h { color: #fb0 }
			.c { display: inline; margin-left: 1em }

		</style>
	</head>

	<body>
		<div id="container"></div>

		<div id="footer">
			<div class="c">
			day / night: <span class="h">n</span>
			</div>

			<div class="c">
			animate terrain: <span class="h">m</span>
			</div>
		</div>

		<script src="build/three.js"></script>

		<script src="js/controls/OrbitControls.js"></script>

		<script src="js/BufferGeometryUtils.js"></script>

		<script src="js/shaders/NormalMapShader.js"></script>
		<script src="js/ShaderTerrain.js"></script>

		<script src="js/Detector.js"></script>
		<script src="js/libs/stats.min.js"></script>

		<script id="fragmentShader" type="x-shader/x-fragment">

		uniform sampler2D oceanTexture;
	    uniform sampler2D sandyTexture;
	    uniform sampler2D grassTexture;
	    uniform sampler2D rockyTexture;
	    uniform sampler2D snowyTexture;

	    varying vec2 vUV;

	    varying float vAmount;

	    void main() 
	    {
	        vec4 water = (smoothstep(0.01, 0.25, vAmount) - smoothstep(0.24, 0.26, vAmount)) * texture2D( oceanTexture, vUV * 10.0 );
	        vec4 sandy = (smoothstep(0.24, 0.27, vAmount) - smoothstep(0.28, 0.31, vAmount)) * texture2D( sandyTexture, vUV * 10.0 );
	        vec4 grass = (smoothstep(0.28, 0.32, vAmount) - smoothstep(0.35, 0.40, vAmount)) * texture2D( grassTexture, vUV * 20.0 );
	        vec4 rocky = (smoothstep(0.30, 0.50, vAmount) - smoothstep(0.40, 0.70, vAmount)) * texture2D( rockyTexture, vUV * 20.0 );
	        vec4 snowy = (smoothstep(0.50, 0.65, vAmount))                                   * texture2D( snowyTexture, vUV * 10.0 );
	        gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0) + water + sandy + grass + rocky + snowy; //, 1.0);
	    }  

		</script>

		<script id="vertexShader" type="x-shader/x-vertex">

		uniform sampler2D bumpTexture;
	    uniform float bumpScale;
	    uniform float textRepeat;

	    varying float vAmount;
	    varying vec2 vUV;

	    void main() 
	    { 
	        vUV = uv * textRepeat;
	        vec4 bumpData = texture2D( bumpTexture, uv );

	        vAmount = bumpData.r; // assuming map is grayscale it doesn't matter if you use r, g, or b.

	        // move the position along the normal
	        vec3 newPosition = position + normal;// * bumpScale * vAmount;

	        gl_Position = projectionMatrix * modelViewMatrix * vec4( newPosition, 1.0 );
	    }

		</script>

		<script>

			if ( ! Detector.webgl ) Detector.addGetWebGLMessage();

			var SCREEN_WIDTH = window.innerWidth;
			var SCREEN_HEIGHT = window.innerHeight;

			var renderer, container, stats;

			var camera, scene;
			var cameraOrtho, sceneRenderTarget;

			var uniformsNoise, uniformsNormal,
				heightMap, normalMap,
				quadTarget;

			var directionalLight, pointLight;

			var terrain;

			var textureCounter = 0;

			var animDelta = 0, animDeltaDir = -1;
			var lightVal = 0, lightDir = 1;

			var clock = new THREE.Clock();

			var updateNoise = true;

			var animateTerrain = false;

			var mlib = {};

			init();
			animate();

			function initCube() {
			    cube = new THREE.Mesh(new THREE.CubeGeometry(2, 2, 2), new THREE.MeshNormalMaterial());
			    scene.add(cube);
			}

			function initSkybox() {
		        var skyboxGeometry = new THREE.CubeGeometry( 20000, 20000, 10000 );
		        var skyboxMaterial = new THREE.MeshBasicMaterial( { color:0x9999ff, side:THREE.BackSide } );
		        var skyBox = new THREE.Mesh( skyboxGeometry, skyboxMaterial );
		        //materials.push( skyboxMaterial );
		        scene.add( skyBox );	

			}

		    // function getImageData( image ) {
		    //     var canvas = document.createElement( 'canvas' );
		    //     canvas.width = image.width;
		    //     canvas.height = image.height;
		    //     var context = canvas.getContext( '2d' );
		    //     context.drawImage( image, 0, 0 );
		    //     return context.getImageData( 0, 0, image.width, image.height );

		    // }

			function initTerrain() {

				terrainGeometry = new THREE.PlaneGeometry( 4096, 4096, 511, 511 ); // image is 512x512, so we need that -1 here.
            	terrainGeometry.dynamic = true;

            	var heightScale = 200.0; // 200.0

            	var textureLoader = new THREE.TextureLoader();

            	var heightmapTexture = textureLoader.load('textures/tex/heightmap.jpg')
 	
 			// 	object.material.uniforms.tDisplacement.value = heightmapTexture;
				// object.material.uniforms.uDisplacementScale.value = 2.436143 * 100; 

            	var oceanTexture = textureLoader.load('textures/tex/dirt-512.jpg')
		        oceanTexture.wrapS = oceanTexture.wrapT = THREE.RepeatWrapping;
		        oceanTexture.repeat.set( 10, 10 );
		        
		        var sandyTexture = textureLoader.load('textures/tex/sand-512.jpg' );
		        sandyTexture.wrapS = sandyTexture.wrapT = THREE.RepeatWrapping;
		        // sandyTexture.repeat.set( 50, 50 );
		        
		        var grassTexture = textureLoader.load('textures/tex/grass-512.jpg' );
		        grassTexture.wrapS = grassTexture.wrapT = THREE.RepeatWrapping;
		        
		        var rockyTexture = textureLoader.load('textures/tex/rock-512.jpg' );
		        rockyTexture.wrapS = rockyTexture.wrapT = THREE.RepeatWrapping;
		        
		        var snowyTexture = textureLoader.load('textures/tex/snow-512.jpg'  );
		        snowyTexture.wrapS = snowyTexture.wrapT = THREE.RepeatWrapping;

				var customUniforms = {
	                bumpTexture:	{ type: "t", value: heightmapTexture },
	                bumpScale:	    { type: "f", value: heightScale },
	                oceanTexture:	{ type: "t", value: oceanTexture },
	                sandyTexture:	{ type: "t", value: sandyTexture },
	                grassTexture:	{ type: "t", value: grassTexture },
	                rockyTexture:	{ type: "t", value: rockyTexture },
	                snowyTexture:	{ type: "t", value: snowyTexture },
	                textRepeat:     { type: "f", value: 8 }
	            };

            	var customMaterial = new THREE.ShaderMaterial( {
                uniforms: customUniforms,
                vertexShader: document.getElementById( 'vertexShader' ).textContent,
                fragmentShader: document.getElementById( 'fragmentShader' ).textContent,
                wireframe: false
                // side: THREE.DoubleSide
            	} );

            	terrain = new THREE.Mesh( terrainGeometry,  customMaterial );
	            terrain.rotation.x = -Math.PI / 2;
	            // terrain.position.y = -180; // changed by offset?
	            terrain.name = "Terrain";
	            scene.add( terrain );

			}


			function init() {

				container = document.getElementById( 'container' );

				// SCENE (RENDER TARGET)
				// CAMERA
				k = 0.01
				terrain_width = 1600
				terrain_height = 900
				// camera = new THREE.OrthographicCamera( k*terrain_width / - 2, k*terrain_width / 2, k*terrain_height / 2, k*terrain_height / - 2, -10000, 10000 );
				// camera.position.z = 10;
				camera = new THREE.PerspectiveCamera( 40, SCREEN_WIDTH / SCREEN_HEIGHT, 2, 4000 );
				camera.position.set( 0, 50, 0 );


				controls = new THREE.OrbitControls( camera );
				controls.target.set( 0, 0, 0 );

				controls.rotateSpeed = 1.0;
				controls.zoomSpeed = 1.2;
				controls.panSpeed = 0.8;

				controls.keys = [ 65, 83, 68 ];

				// SCENE (FINAL)

				scene = new THREE.Scene();
			    initCube();
			    // initSkybox();
			    initTerrain();

    			// initCamera();
				// scene.fog = new THREE.Fog( 0x34583e, 2000, 4000 );

				// LIGHTS

				// scene.add( new THREE.AmbientLight( 0x111111 ) );

				// directionalLight = new THREE.DirectionalLight( 0xffffff, 1.15 );
				// directionalLight.position.set( 500, 2000, 0 );
				// scene.add( directionalLight );

				// pointLight = new THREE.PointLight( 0xff4400, 1.5 );
				// pointLight.position.set( 0, 0, 0 );
				// scene.add( pointLight );


				// // HEIGHT + NORMAL MAPS

				// var normalShader = THREE.NormalMapShader;

				// var rx = 256, ry = 256;
				// var pars = { minFilter: THREE.LinearFilter, magFilter: THREE.LinearFilter, format: THREE.RGBFormat };

				// heightMap  = new THREE.WebGLRenderTarget( rx, ry, pars );
				// heightMap.texture.generateMipmaps = false;

				// normalMap = new THREE.WebGLRenderTarget( rx, ry, pars );
				// normalMap.texture.generateMipmaps = false;

				// uniformsNoise = {

				// 	time:   { value: 1.0 },
				// 	scale:  { value: new THREE.Vector2( 1.5, 1.5 ) },
				// 	offset: { value: new THREE.Vector2( 0, 0 ) }

				// };

				// uniformsNormal = THREE.UniformsUtils.clone( normalShader.uniforms );

				// uniformsNormal.height.value = 0.05;
				// uniformsNormal.resolution.value.set( rx, ry );
				// uniformsNormal.heightMap.value = heightMap.texture;

				// var vertexShader = document.getElementById( 'vertexShader' ).textContent;

				// // TEXTURES

				// var loadingManager = new THREE.LoadingManager( function(){
				// 	terrain.visible = true;
				// });
				// var textureLoader = new THREE.TextureLoader( loadingManager );

				// var specularMap = new THREE.WebGLRenderTarget( 2048, 2048, pars );
				// specularMap.texture.generateMipmaps = false;

				// var diffuseTexture1 = textureLoader.load( "textures/terrain/grasslight-big.jpg");
				// var diffuseTexture2 = textureLoader.load( "textures/terrain/backgrounddetailed6.jpg" );
				// var detailTexture = textureLoader.load( "textures/terrain/grasslight-big-nm.jpg" );

				// diffuseTexture1.wrapS = diffuseTexture1.wrapT = THREE.RepeatWrapping;
				// diffuseTexture2.wrapS = diffuseTexture2.wrapT = THREE.RepeatWrapping;
				// detailTexture.wrapS = detailTexture.wrapT = THREE.RepeatWrapping;
				// specularMap.texture.wrapS = specularMap.texture.wrapT = THREE.RepeatWrapping;

				// // TERRAIN SHADER

				// var terrainShader = THREE.ShaderTerrain[ "terrain" ];

				// uniformsTerrain = THREE.UniformsUtils.clone( terrainShader.uniforms );

				// uniformsTerrain[ 'tNormal' ].value = normalMap.texture;
				// uniformsTerrain[ 'uNormalScale' ].value = 3.5;

				// uniformsTerrain[ 'tDisplacement' ].value = heightMap.texture;

				// uniformsTerrain[ 'tDiffuse1' ].value = diffuseTexture1;
				// uniformsTerrain[ 'tDiffuse2' ].value = diffuseTexture2;
				// uniformsTerrain[ 'tSpecular' ].value = specularMap.texture;
				// uniformsTerrain[ 'tDetail' ].value = detailTexture;

				// uniformsTerrain[ 'enableDiffuse1' ].value = true;
				// uniformsTerrain[ 'enableDiffuse2' ].value = true;
				// uniformsTerrain[ 'enableSpecular' ].value = true;

				// uniformsTerrain[ 'diffuse' ].value.setHex( 0xffffff );
				// uniformsTerrain[ 'specular' ].value.setHex( 0xffffff );

				// uniformsTerrain[ 'shininess' ].value = 30;

				// uniformsTerrain[ 'uDisplacementScale' ].value = 375;

				// uniformsTerrain[ 'uRepeatOverlay' ].value.set( 6, 6 );

				// var params = [
				// 	[ 'heightmap', 	document.getElementById( 'fragmentShaderNoise' ).textContent, 	vertexShader, uniformsNoise, false ],
				// 	[ 'normal', 	normalShader.fragmentShader,  normalShader.vertexShader, uniformsNormal, false ],
				// 	[ 'terrain', 	terrainShader.fragmentShader, terrainShader.vertexShader, uniformsTerrain, true ]
				//  ];

				// for( var i = 0; i < params.length; i ++ ) {

				// 	material = new THREE.ShaderMaterial( {

				// 		uniforms: 		params[ i ][ 3 ],
				// 		vertexShader: 	params[ i ][ 2 ],
				// 		fragmentShader: params[ i ][ 1 ],
				// 		lights: 		params[ i ][ 4 ],
				// 		fog: 			false
				// 		} );

				// 	mlib[ params[ i ][ 0 ] ] = material;

				// }


				// var plane = new THREE.PlaneBufferGeometry( SCREEN_WIDTH, SCREEN_HEIGHT );

				// quadTarget = new THREE.Mesh( plane, new THREE.MeshBasicMaterial( { color: 0x000000 } ) );
				// quadTarget.position.z = -500;
				// sceneRenderTarget.add( quadTarget );

				// TERRAIN MESH

				// var geometryTerrain = new THREE.PlaneBufferGeometry( 6000, 6000, 256, 256 );

				// THREE.BufferGeometryUtils.computeTangents( geometryTerrain );

				// terrain = new THREE.Mesh( geometryTerrain, mlib[ 'terrain' ] );
				// terrain.position.set( 0, -125, 0 );
				// terrain.rotation.x = -Math.PI / 2;
				// terrain.visible = false;
				// scene.add( terrain );

				// RENDERER

				renderer = new THREE.WebGLRenderer({antialias:true});
				// renderer.setClearColor( 0xffffff );
				// renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( SCREEN_WIDTH, SCREEN_HEIGHT );
				container.appendChild( renderer.domElement );

				// STATS

				stats = new Stats();
				container.appendChild( stats.dom );

				// EVENTS

				onWindowResize();

				window.addEventListener( 'resize', onWindowResize, false );

				document.addEventListener( 'keydown', onKeyDown, false );

			}

			//

			function onWindowResize( event ) {

				SCREEN_WIDTH = window.innerWidth;
				SCREEN_HEIGHT = window.innerHeight;

				renderer.setSize( SCREEN_WIDTH, SCREEN_HEIGHT );

				camera.aspect = SCREEN_WIDTH / SCREEN_HEIGHT;
				camera.updateProjectionMatrix();

			}

			//

			function onKeyDown ( event ) {

				switch( event.keyCode ) {

					case 78: /*N*/  lightDir *= -1; break;
					case 77: /*M*/  animDeltaDir *= -1; break;

				}

			}

			//

			function animate() {

				requestAnimationFrame( animate );

				render();
				stats.update();

			}

			function render() {

				var delta = clock.getDelta();

				// if ( terrain.visible ) {

					controls.update();

					// var time = Date.now() * 0.001;

					// var fLow = 0.1, fHigh = 0.8;

					// lightVal = THREE.Math.clamp( lightVal + 0.5 * delta * lightDir, fLow, fHigh );

					// var valNorm = ( lightVal - fLow ) / ( fHigh - fLow );

					// scene.fog.color.setHSL( 0.1, 0.5, lightVal );

					// renderer.setClearColor( scene.fog.color );

					// directionalLight.intensity = THREE.Math.mapLinear( valNorm, 0, 1, 0.1, 1.15 );
					// pointLight.intensity = THREE.Math.mapLinear( valNorm, 0, 1, 0.9, 1.5 );

					// uniformsTerrain[ 'uNormalScale' ].value = THREE.Math.mapLinear( valNorm, 0, 1, 0.6, 3.5 );


					// if ( updateNoise ) {

						// animDelta = THREE.Math.clamp( animDelta + 0.00075 * animDeltaDir, 0, 0.05 );
						// uniformsNoise[ 'time' ].value += delta * animDelta;

						// uniformsNoise[ 'offset' ].value.x += delta * 0.05;

						// uniformsTerrain[ 'uOffset' ].value.x = 4 * uniformsNoise[ 'offset' ].value.x;

						// quadTarget.material = mlib[ 'heightmap' ];
						// renderer.render( sceneRenderTarget, cameraOrtho, heightMap, true );

						// quadTarget.material = mlib[ 'normal' ];
						// renderer.render( sceneRenderTarget, cameraOrtho, normalMap, true );

					// }

					renderer.render( scene, camera );

				// }

			}

		</script>

	</body>
</html>
